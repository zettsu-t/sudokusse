SSE4.2版 数独ソルバー 説明

[アセンブリ記述]

sudokusse.s のメモリアクセスは、すべてRIP-relative (instruction pointer
からの相対アドレス)にする。つまり
        movdqa  xmm0,  xmmword ptr [sudokuXmmToPrint]
ではなく、
        movdqa  xmm0,  xmmword ptr [rip + sudokuXmmToPrint]
と記述する。そのようにしないと、MinGW-w64ではリンクできるが、Cygwinでは
リンクできない。


[コンパイルおよびリンク時の注意]

sudokusse.exeにC/C++ライブラリをスタティックリンクしないと、Cygwinから
起動したときにlibstdc++-6.dllをリンクできないので、起動できなくなる。


[実行時間]

実行時間を下記の通り表示する。
usecはmicro second(マイクロ秒=百万分の1秒)の略である。

+ Totalは総実行時間、averageは実行1回当たりの平均時間
+ Once leastは1回解くのに掛かった最小時間

この時間は数独を解くためだけに掛かる時間で、初期マップファイルを
読み込む時間は入っていないが、解く過程を表示するための時間は入っている。
1回しか実行しない場合でもOnce leastはTotalより短くなるが、これはTotalの
方が計測区間が長いからである。

平均が最小時間時間を大きく上回るのは、以下の理由と推測される。

1. sudoku*.exeの実行プロセス以外のプロセスにCPUが取られる(MsysやCygwinの
   コンソール表示も含む)

2. CPUのキャッシュ(特にL1命令キャッシュ)のヒット率が変わる
   (特に他プロセスにCPUを取られた後)

3. 数独の解の数を求めるように、実行時間が数秒-数分間でも、時間が倍近く
   変わることがある。数独以外のタスクに時間を取られたというだけでは
   説明がつかないので、CPUが温度上限に達して減速した可能性がある。

2については、Win32 APIのSetProcessAffinityMask()を呼び出して、プロセッサ
割り当てを固定することで実行時間を短縮できる。

3については、下記の通りOSの設定を変更することで対策出来る。

+ Windows 7の電源オプションを高パフォーマンスにする。
+ プロセッサの電源管理を、下記の通り設定する。
  最小のプロセッサの状態 = 最大のプロセッサの状態 = 100%
  システムの冷却ポリシー = アクティブ


[数独を解く過程の表示]

解く過程を示す場合は、実行過程を示す。各行が数独の各行である。各列の:で
区切られた連続する数字が、そのマスのその時点での候補となりうる数字の
集合である。

たとえば":123:"であれば、そのマスの候補となる数字は1と2と3であり、
4から9は候補にはなりえないと(その時点では)判断したことを示す。

終了時すなわち解けた時には、すべてのマスの候補が一意に(1から9のうち
どれか一つの数字に) なっているはずである。


[データ構造(C++版 : 数独を解く)]
<SudokuCellクラス>
数独のマスである。全部で81個ある。
メンバcandidates_に、候補となる数字の集合を保持する。

<SudokuCellCandidates>
マスの候補となる数字の集合をビットマップで持っている。
1を候補に持つときはbit 0が0(0x01), 2を候補に持つときはbit 1が1(0x02),
(中略) 9を候補に持つときはbit 8が1(0x100)になる。候補に持たないときは
それぞれ0である。1から9まで全部候補に持つなら0x1ffである。

この型はunsigned intにしている。unsigned shortでも表現可能だが、
演算は遅くなる(当方の環境=Intel Core i3 550 3.20GHzではそうなる)。

<SudokuMapクラス>
数独の全マスのことである。左上から順に、
  0,  1, ... ,  9
  9, 10, ... , 17
   ...
 72, 73, ... , 80
と番号を振っている(SudokuCell::indexNumber_)。

<SudokuMap::Group_>
<SudokuMap::ReverseGroup_>
それぞれのマスが、どの横一行、縦一列、3*3箱に属しているかを調べる早見表
である(後者から前者がGroup_, 逆がReverseGroup_)。
行は上から下に向かって0..8, 列は左から右に向かって0..8, 箱は、
 0, 1, 2
 3, 4, 5
 6, 7, 8
である。手計算では大変なので、sudokumap.rbに計算させて、sudokumap.cppに
出力する。

<SudokuCellLookUp>
マスの候補SudokuCellCandidatesを与えられたとき、その属性を調べる。
なぜなら、ビット数を一々数えると時間が掛かるからである。C++に
population count 演算があれば速くなると考え、SSE 4.2版を作成した。

テーブルの要素数は512個(2^9) * 4byte = 2Kbyteであるが、
1st Data Cache (32Kbyte)に収まるので問題ない。

<SudokuSolverクラス>
文字列を与えると、数独を解く。ここに与える文字列は、初期マップファイル
の中身を各行9文字=9 byte)に丸めて、改行文字を除いて、先頭9行だけ取り出
したもの(81文字=81 byte)である。ただし先頭行が81文字以上あれば、その
先頭81文字を初期マップとして扱う。

<SudokuLoaderクラス>
コマンドライン引数を解釈して、初期マップファイルを読んで、数独を解いて、
実行時間を測る。


[データ構造(SSE 4.2版 : 数独を解く]
クラス名はSudokuSse*

XMMレジスタ上に以下の通りマスを配置する。
XMM1: 1行目, ... XMM-N: N行目 ... , XMM9: 9行目

XMM1..9レジスタ(128bit) : 1行分の構造
  => 0(32bit) , 左3マス(32bit) , 中3マス(32bit) , 右3マス(32bit)
3マス分(32bit) => 0(5bit), 左マス(9bit), 中マス(9bit), 右マス(9bit)
1マス分 => bit 8(最左)が1なら9が候補, ... , bit 0(最右)が1なら1が候補
  つまりSudokuCellCandidatesと同じ。

Little endianなのでXMMレジスタからメモリにコピーすると左右が逆転する。
32bitダンプ: 右3マス(32bit), 中3マス(32bit), 左3マス(32bit),  0(32bit)
64bitダンプ: 中3マス(32bit)<<32 | 右3マス(32bit), 0(32bit) | 左3マス(32bit)

その他のXMMレジスタの用途は下記のとおりである。
XMM0  : 各列にある唯一のマスのorを1行にまとめたもの
XMM10 : 1..3行目にある唯一のマスのorを1行にまとめたもの
XMM11 : 4..6行目にある唯一のマスのorを1行にまとめたもの
XMM12 : 7..9行目にある唯一のマスのorを1行にまとめたもの
XMM15 : 反復前の唯一のマスの合計数
XMM13, XMM14は計算用の一時領域

汎用レジスタ:
rbp, rsp : 変更しない
r15 : ビットマスクを定数で持つ
それ以外のレジスタはすべて計算用の一時領域に使う

ASMのシンボルがC++と違ってしまっているのは、両者を作るのに期間が相当
空いたためであり、お見苦しい点ご了承頂きたい。


[データ構造(SSE 4.2版 : 数独の解の数を求める]
クラス名はSudokuSseEnumeratorMap

XMMレジスタ上に以下の通りマスを配置する。
XMM1: 1行目の左から8マス, ... , XMM9: 9行目の左から8マス
XMM10: 右の列を1行目 ... 8行目
sudokuXmmRightBottomElement : 右下(9行目かつ9列目)の初期値
sudokuXmmRightBottomSolved  : 右下(9行目かつ9列目)を解いた結果
  xmm1  : (0,0), ... , (7,0)
  xmm9  : (0,8), ... , (7,8)
  xmm10 : (8,0), ... , (8,7)

XMM1..9 : 下位word(16 bit単位)から1..8列 [8, 7, 6, 5, 4, 3, 2, 1列名]
XMM10   : 下位word(16 bit単位)から1..8行 [8, 7, 6, 5, 4, 3, 2, 1行目の最右]

マスの数字をビットマップで持っている。1のときはbit 0が0(0x01), 2のとき
はbit 1が1(0x02),(中略)9のときはbit 8が1(0x100)になる。候補に持たないと
きは0である。複数のbitが同時に1になることはない。


[アルゴリズム]

"プログラマのための論理パズル 難題を突破する論理思考トレーニング",
 Dennis E. Shasha (著), 吉平 健治 (翻訳), 2009/3, オーム社

に記載されている3つの手順を適用する。

1. あるマスにとって、唯一の候補となる数字があればそれを埋める。
   これを9*9=81マス繰り返す

2. あるマスにとって、他のマス候補となりえない数字があればそれを埋める。
   これを9*9=81マス繰り返す

3. 1と2を繰り返して手詰まりになる(候補が減らない)と、候補を決め打ちして
   進む。それで解ければ終わり、解けなければ決め打ちからやり直す
   (バックトラッキング)

<1. 唯一の候補>
マスの属する縦、横、3*3箱すべてにおいて、確定している(候補が唯一となっ
ている)マスで使われている数字を全部集める。それらの数字が8種類なら、
残り1種類を設定する。例えば、

横一行が *23456789 => *は1

横一行、縦一列、3*3箱が下記の通りなら
  *..123...
  456
  7
  8
*は9に決まる。

この規則を拡張すると、マスの属する縦、横、3*3箱すべてにおいて、確定して
いる(候補が唯一となっている)マスで使われている数字を全部集める。それら
の数字以外と、現在の候補の積集合(and)をこの設定する。例えば、
  *..12....
  3456
  7
であれば、*は{8,9}と、*にすでに入っている候補とのANDである。

<2. 他になりえない候補>

マスの属する3*3箱の他のマスにおいて、候補とはなりえない数字が1つだけ
あればそれを設定する。例えば、
  *12......
  ???4..7..
  !??...4..
  .7.
  ...
  ...
  ..7
という状況を考える。このとき?と!の6マスはすべて、4を候補に取ることがで
きない(同じ行に4があるため)。1と2のマスは確定しているので当然4にはなり
えない。よって左上の3*3箱で、*以外のマスに4を設定することはできない。
そのため*は4に確定する。

同様のことが、縦一行、横一列、3*3箱についても適用できる。上記の後、
7について同じことを行うと、!を7に絞れる。

<3. バックトラッキング>

候補の選び方は以下の通り

C++版:
1. もっとも候補の少ないマスを選ぶ
2. 1において、マスの候補数が同数であるために複数の行が候補となる場合は、
  行全体の候補数がの少ない行を選ぶ
3. 1,2は、同じ行の同じ候補数のマスであれば、最初に見つけたものを使う

2については列でも、3*3箱でもよいが、手元で試した例では行がもっとも
解く時間が速くなる。

SSE 4.2版:
もっとも候補の少ないマスを最初に見つけたらそれのマスにする。
行は上から下、同じ行は右から左の順で、行内を探して見つからなければ
次の行に移る。

ASM版がC++版より高速なのは、単に候補の選び方を単純にしたから、という
影響もあるとみられる。

バックトラッキングでは、解きかけの数独マップをそのままコピーする。
メンバ変数は基本型しかないので、単なるメモリコピーで済み、オブジェクト
のエイリアシングは発生しない。


[アルゴリズム(数独の解の数を求める)]

バックトラッキングだけを行う。

あらかじめ埋まっているマスが、上から下、左から右に集まっている(上の行か
ら埋まる、埋まっているマスの最下行は左から右に埋まる)ことを仮定すると
速くなる(下記例を参照)。この仮定をなくすには、CellsPackedシンボルを0に
設定する。

  123456789
  456789123
  789123456
  2958.....
  .........
  .........
  .........
  .........
  .........


最右列と最下行は、候補が高々一つしかないことが分かっているので、マスの
候補を1から9個列挙して埋めてから残りのマスをバックトラッキングする処理
を、ループにしないようにする。


[高速化手法]

プロファイラを使用していないので、高速化にどの程度寄与したかについて、
定量的な根拠はありません。

* inlineキーワードはマクロで有効/無効を切り替えられるようにしている。
  通常の実行ファイル(sudoku*.exe)では有効、CppUnitによるテストでは無効に
  している。CppUnitでinlineキーワードを有効にするとビルドに失敗する。

* 仮想関数テーブルをなくすと速くなるので、今は無くしている。従って、
  デストラクタを宣言も定義もしない。正当な作法として仮想デストラクタ
  を作るのであれば、NO_DESTRUCTOR_AND_VTABLEマクロを定義しない。

* 基本型はすべてtypedefしてある。型の定義次第で実行速度は上がったり下がっ
  たりするので、いろいろ試してみた。当方の環境では、現状の型宣言の組み合
  わせが最速である。

* constは定数も、引数も、constメンバ関数も積極的に使う。

* ループは手作業で積極的にインライン展開する。ただし、ループ内の条件
  分岐が複雑だと、ループを展開した方が却って遅くなる。プロセッサの分岐
  予測の妨げになるのであれば、展開しすぎである。

* ループ展開は、メンバ関数テンプレートを用いた再帰呼び出しによって実現
  するのを基本とする。最後は全部インライン展開されるので、再帰呼び出し
  のコストはゼロである。

* ループ展開で、インライン関数の中から一気にインラインしている外の関数
  まで脱出することはできない。こういうときは仕方ないので、インライン
  関数の代わりに#define func { ... return; }を使っている。

* "#define FAST_MODE true"をfalseに変えると、高速化しないバージョンに
  なる。手作業で変更してからビルドし直して実行すると、かなり遅くなるの
  が分かる。

* if文の中が定数なら、定数伝搬による最適化によって、if文と使われない方
  のブロックがバイナリからなくなる。

* SudokuCell::CountCandidatesIfMultipleを
  SudokuCell::MaskCandidatesUnlessMultipleと組み合わせると、
  この関数の呼び出し先(値の利用先)でif文を削除できる。

* 最適化レベルは-O2にしている。-O3にすると却って遅くなることがある。

* 再帰呼び出しにおいて、retではなく、pop + jmpで再帰呼び出しから戻る方
  が速くなる。詳しくは下記文献のAppendix.C に記載の、命令のレイテンシ
  を参照。

   "Intel 64 and IA-32 Architectures Optimization Reference Manual"

   http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html

□
