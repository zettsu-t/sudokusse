Sudoku solver with SSE4.2 / AVX
Copyright (C) 2012-2016 Zettsu Tatsuya

[[Platform]]
[Building]
+ Windows 8.1 64bit Edition

+ Cygwin 64bit version (2.2.1)
 - GNU Make 4.1
 - g++ 4.9.3
 - GNU assembler 2.25
 - Ruby 2.2.2p95
 - Perl 5.22.0
or
+ MinGW-w64 for 64 bit Windows
 - GNU Make 4.1
 - g++ 4.9.2
 - GNU assembler 2.24
 - Ruby (ActiveScriptRuby 2.2.0p0 etc.)
 - perl and rm in Cygwin (set environment variable PATH to find them)

[Running]
Cygwin and Perl (same version as described above)

[Testing]
CppUnit 1.12.1


[[How to build]]

1. Launch a terminal and change its current directory to a directory
  that contains sudoku.cpp.

  $ cd .../sudokusse

2. Execute make without arguments to build.

  $ make (or mingw32-make in MinGW)

After built successfully, these two executable files are generated.
(I call them Sudoku.exe in this document)

  sudokusse.exe (standard)
  sudokusse_cells_packed.exe (special ; explained later)


[[Switch SSE4.2 and AVX]]

Set the environment EnableAvx in sudokusse.s to 0 for SSE4.2 and 1 for
AVX. This is designated at compile-time (not runtime) and "make"
passes it to as.exe as an option.


[[Prepare Sudoku puzzles]]

Sudoku.exe accepts a sudoku puzzle in a text file.
+ For cells with an initial number, write the number (1 to 9).
+ For cells which are blank and going to be filled, write a printable
  non-number character such as a period or white space.

[Format 1 : 9 characters x 9 lines]
.3.....4.
.1..97.5.
..25.86..
..3...8..
9....43..
..76....4
..98.54..
.7.....2.
.5..71.8.

Sudoku.exe reads first nine lines and first nine characters in each
line of an input file. No indents are allowed.

[Format 2 : 81 characters in one line]
.3.....4..1..97.5...25.86....3...8..9....43....76....4..98.54...7.....2..5..71.8.

Sudoku.exe reads first 81 characters of an input text.

Redundant lines are not parsed in both formats and you can write
anything there as comments.


[[Count how many patterns a Sudoku puzzle has]]

Execute from a terminal

  $ bin/sudokusse.exe 0 < puzzle_text_filename

and Sudoku.exe prints the number of patterns of "puzzle_text_filename"
and its execution time.

Set a non-zero number as a second argument

  $ bin/sudokusse.exe 0 100 < puzzle_text_filename

and Sudoku.exe prints 100 patterns and exits after all patterns counted.

bin/sudokusse_cells_packed.exe assumes Sudoku cells are packed at the
top left corner of a puzzle. This means the puzzle has such nine lines
from its top to bottom ordered by
  a. filled nine cells (0 or more lines)
  b. filled cell(s) followed by blank cell(s) (none or one line)
  c. blank nine cells (0 or more lines)


[[Solve a Sudoku puzzle]]

Execute from a terminal

  $ bin/sudokusse.exe times_to_solve < puzzle_text_filename

When "times_to_solve" is a positive integer number, Sudoku.exe solves
the same input puzzle "times_to_solve" times and prints execution time
to solve once.

When "times_to_solve" is a negative integer number, Sudoku.exe solves
absolute "times_to_solve" times (5 times for -5) and prints steps to
solve it. Usually specify -1 to check the steps.

bin/sudokusse_cells_packed.exe prints "Cannot solve" error message
because it assumes cells are packed and misses blank cells.


[[Helper scripts]]

[1. Time to solve]

Execute

  $ perl sudoku_count.pl puzzle_text_filename

and this script launches sudoku*.exes and writes results to a log file
which is named with current time such as SudokuTime_2013_09_27_21_34_56.log.

This repeats infinitely and you need to hit ctrl-c many times to abort.
(hitting once can break sudoku*.exe and may not break the script.)

[2．Search minimum execution time to solve from the log file]

Execute

  $ perl sudoku_search_timelog.pl SudokuTime_2013_09_27_21_34_56.log

and this script parses the log SudokuTime_2013_09_27_21_34_56.log
(or other specified file name) and print minimum execution time to solve.


[[Testing]]
[1. Check to solve puzzles correctly]

Execute

  $ perl sudoku_solve_all.pl

and the script solve puzzles in data/*.txt . When the puzzles are
solved correctly, the script prints execution time elapsed. When one
of the puzzles cannot solved correctly, the script aborts immediately.

[2. Test C++ functions and assembly macros]

Change current directory to unittest/ and execute

  $ make

If the make command completes successfully, it generated unittest.exe
and unittest_cells_packed.exe, ran them and reports testing result
which indicates all tests passed.


[[Notice to write and modify code]]
[C++]
This code are written in C++11 and requires a C++11 option to compile.

[Assembly]
All memory accesses in sudokusse.s require RIP (instruction pointer)
relative addressing.

    movdqa  xmm0,  xmmword ptr [sudokuXmmToPrint]

is not allowed and

    movdqa  xmm0,  xmmword ptr [rip + sudokuXmmToPrint]

is right. MinGW-w64 may accept non-RIP-relative addressing but Cygwin
causes link errors.


[[Execution time]]

Sudoku.exe prints its execution time (usec means micro second =
1/1000000 second). The execution time excludes reading an input file
and includes printing time to a terminal.

+ Total : all execution time in repetition
+ average : total / number of repetition
+ Once least : least execution time in repetition

Even when Sudoku.exe solves a puzzle once, Once least is shorter than
Total because check points of time stamp are different.

I assume average is much longer than least in these reasons.

1. Other processes including terminals consume a CPU.

2. Cache hit rate varies. Especially after an processes preempted
  Sudoku.exe, Sudoku.exe gets cold cache that causes cache miss.
  Calling Win32 SetProcessAffinityMask() improves the cold cache
  problem.

3. A CPU reaches its thermal limit and slows down. Setting of the
 Windows power option may relax this situation.


[[Print steps to solve a Sudoku puzzle]]

Each line matches a line of an input puzzle and ":" splits cells in
a line. Numbers in a cell means candidates of the cell at a step.

For example ":123:" means the cell contains 1 or 2 or 3 but cannot
contain 4 to 9 (Sudoku.exe judges so at the step). When the puzzle
solved completely, each cell has a unique number.


[[Data structure]]

[C++ to solve]
<SudokuCell>
A cell in a Sudoku puzzle. The puzzle contains 81 cells.
The member candidates_ contains candidate number set.

<SudokuCellCandidates>
Candidate number set as a bitmap.

Set bit 0 (0x01) of the bitmap when 1 is a candidate and reset bit 0
when is not a candidate. Set and reset in the manner 2 for bit 1
(0x02) ...  9 for bit 8 (0x100). If all 1 to 9 are candidates, the
bitmap has 0x1ff.

I define this type as unsigned int (uint32_t). Unsigned short
(uint16_t) can hold the bitmap but is slow to calculate.

<SudokuMap>
All cells in a Sudoku puzzle. Numbered left to right, top to bottom,
  0,  1, ... ,  9
  9, 10, ... , 17
   ...
 72, 73, ... , 80
(SudokuCell::indexNumber_)。

<SudokuMap::Group_>
<SudokuMap::ReverseGroup_>
Look up table in which each cell is in which row, column, or 3x3 box.
Group_ looks up forward (a 9 cells group to cells) and ReverseGroup_
looks up reverse (a cell to 9 cells groups).

Rows are numbered top to bottom, columns are numbered left to right,
and boxes are placed as shown below.
  0, 1, 2
  3, 4, 5
  6, 7, 8
sudokumap.rb generates these tables as sudokuConstAll.h.

<SudokuCellLookUp>
SudokuCellLookUp checks properties of SudokuCellCandidates to avoid
bit operation (standard C++ lacks population count and I wrote
assembly version with SSE popcnt).

SudokuCellLookUp has 512 (=2^9) entries * 4byte = 2Kbyte and
L1 data cache (32Kbyte) can hold it whole.

<SudokuSolver>
SudokuSolver receives a given string, extracts 81 characters as cells
and solve it. In extracting, it parses input lines and detects in
which format a sudoku puzzle is described.

<SudokuLoader>
SudokuLoader understands command line options, read a sudoku puzzle
file, solve it and measure its execution time.

[SSE4.2/AVX to solve]
Classes SudokuSse*.

XMM registers holds cells as followed.

XMM1: 1st row, ... XMM-N: Nth row ... , XMM9: 9th row

XMM1..9 Register (128bit) holds a row that contains four 32bit parts
    0(32bit), left 3 cells, middle 3 cells, right 3 cells
and the part (32bit) consists of
    0(5bit), left cell(9bit), middle cell(9bit), right cell(9bit)
and the cell has candidate bitmap as in the form of SudokuCellCandidates
    9 is a candidate(set) or not(reset), ... , 1 is a candidate or not

Note that x86 uses little endian so copying a XMM register to memory
looks like bytes are flipped.
32bit dump : right 3 cells (32bit), middle(32bit), left(32bit), 0(32bit)
64bit dump : ((middle 3 cells:32bit << 32) | right:32bit) , (left:32bit)

Other XMM registers hold data described below.
The term "unique candidate" means
+ if the cell has a unique candidate, the bit mask for a candidate
  (i.e. 1 << (candidate number - 1))
+ zero if the cell has multiple candidates

XMM0  : Logical OR of unique candidates in each column
XMM10 : Logical OR of unique candidates in 1st to 3rd rows
XMM11 : Logical OR of unique candidates in 4th to 6th rows
XMM12 : Logical OR of unique candidates in 7th to 9th rows
XMM15 : Number of cells that have a unique candidate
XMM13, XMM14 : work area

General purpose registers are used for
r15 : a constant for mask bits of candidates
rbp, rsp : not changed
others : work area

[SSE4.2/AVX to count patterns]
SudokuSseEnumeratorMap class

XMM registers hold cells described below.
  xmm1  : (0,0), ... , (7,0)
  xmm9  : (0,8), ... , (7,8)
  xmm10 : (8,0), ... , (8,7)

XMM1..9: Left 8 cells of 1st row, ... , Left 8 cells of 9th row
  Low to high words (16bit * 8) hold 1st to 8th column.
  [Cells in 8, 7, 6, 5, 4, 3, 2, 1st column in a row]

XMM10: Rightest cells of 1st to 8th rows
  Low to high words (16bit * 8) hold 1st to 8th row.
  [Cells at 8, 7, 6, 5, 4, 3, 2, 1st rows in the rightest column]

sudokuXmmRightBottomElement : Preset (written in a given file) number
  of right bottom corner cell

sudokuXmmRightBottomSolved  : Solved (blank in a given file) number
  of right bottom corner cell

Each word (16bit) holds a bitmap in the form of SudokuCellCandidates
  9 is a candidate(set) or not(reset), ... , 1 is a candidate or not
None or one bit in the word is set and multiple bits never be set
simultaneously.


[[Algorithm to solve]]

I apply steps described in Shasha[2007].

1. Fill a candidate of a cell if any. Apply this all 81 (9x9) cells.
2. Find a candidate of a cell if the candidate cannot be set to other cells.
   Apply this all 81 (9x9) cells.
3. Repeat 1 and 2. If decrease of the candidates stops, start backtracking.
   i.e. choose a candidate and repeat 1 and 2 again.

[Step 1]
To find a unique candidate of a cell, collect numbers in cells of
a row, column and box that the cell belongs. For example, size of
the number is 8, the rest is the unique candidate.

When a row has cells *23456789, set 1 to *.

When a row, column and box have cells as shown below,
  *..123...
  456
  7
  8
set 9 to *.

Now we can extend this rule. To find a unique candidate of a cell,
collect numbers not used in cells of a row, column and box that the
cell belongs. For example,
  *..12....
  3456
  7
we apply * to logical AND {8,9}. In other words, we mask * by
the complementary set of {1..7}.

[Step 2]
For a cell, if there is a number that cannot be set in a row, column
and box that the cell belongs, fill the number to the cell.

Consider an example here.
  *12......
  ???4..7..
  !??...4..
  .7.
  ...
  ...
  ..7
The 6 cells marked ? and ! cannot hold 4 because 4 is on the same rows.
The cells filled by 1 and 2 also cannot hold 4. This leads a conclusion
that the cell * only can hold 4.

We can apply this rule for columns and boxes. After filling 4,
we apply the rule for 7 and set 7 to the cell marked !.

[Step 3 : backtracking]
Choose a candidate in a cell in an ongoing sudoku map.

<C++>
1. Select a cell that has least size (2 or more) of candidates in the cells.
2. If multiple cells are selected, select a row that has least size of
   candidates in the cells of the row. (Column and boxes can be used
   the step 2 instead of rows.)
3. If the row have multiple cells that have least and same size of
   candidates, use a cell found first.

<SSE 4.2>
Search cells top to bottom, left to right (scan horizontally) and
select a cell that has least size (2 or more) of candidates in the
cells.

Before starting backtracking, Sudoku.exe makes a copy of the sudoku
map to rewind backtracking. The map has only primitives so we can use
compiler-generated copying (trivial copy) and avoid object aliasing.


[[Algorithm to count]]

Backtracking only. Set a cell to candidate 1 to 9 if not blank and
recursively set other cells.

Assume that cells are packed top left and count fast if the assumption
is true.
  123456789
  456789123
  789123456
  2958.....
  .........
  .........
  .........
  .........
  .........

Note that rightest and bottom cells always have only one candidate
in backtracking and we can avoid setting a candidates to them in the
recursion.


[[Get faster]]

I have no quantitative analysis of these items because I have not used
a profiler to Sudoku.exe.

* Use the inline keyword and switch it via a macro. Sudoku.exe enables
  inlining and unit tests disable inlining. Inlining causes link
  errors in unit tests.

* Eliminate virtual function calls. This also prohibits virtual
  destructor. If you can define virtual destructor as a good practice,
  undefine NO_DESTRUCTOR_AND_VTABLE macro.

* Declare aliases all integer primitives to switch their bit width
  easily. Performance depends on the bit width and I hope current
  combination of bit width makes Sudoku.exe fastest. Different
  processors and compilers may need different bit width.

* Use const and constexpr as much as possible. This is useful to set a
  constant expression in a if-statement. Constant propagation removes
  constant expressions and unused blocks in a if-statement.
  SudokuCell::CountCandidatesIfMultiple and
  SudokuCell::MaskCandidatesUnlessMultiple eliminates if-statements.

* Unroll loops if appropriate. If a loop has complex branch
  conditions, unrolling the loop can disturb branch prediction of a
  processor and makes it run slower.

* Unroll loops with member function templates and recursive call.
  I hope compilers expand the recursive call and there is no overhead
  in runtime.

* Use macros instead of function templates if really needed.
  C++ code cannot break to exit nested loops and use macro
  #define func { ... return; } to do it.

* Change "#define FAST_MODE true" to false and run code that is easy
  to read but slow.

* Set optimization level -O2. -O3 makes Sudoku.exe slower.

* To return from a function in assembly, pop + jmp is faster than ret.


[[Bibliography and acknowledgment]]

1. I cite the Sudoku solver algorithm and puzzle examples from the book.

Dennis E. Shasha (May 2007), "Puzzles for Programmers and Pros", Wrox
(I read its Japanese translation published by Ohmsha. See my Japanese
howtobuild.txt.)

2. I use CppUnit code on the website.

http://www.atmarkit.co.jp/fdotnet/cpptest/cpptest02/cpptest02_02.html

3. I adopt an idea of Mr. Kawai Hidemi to count how many patterns in a
Sudoku puzzle and compare execution time with his program on the
article.

http://developer.cybozu.co.jp/tech/?p=1692

4. I check instruction set and latency of x86_64 on the manual.

"Intel 64 and IA-32 Architectures Optimization Reference Manual"

http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html
